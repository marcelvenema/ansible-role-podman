---
#########################################################
## Podman Import Container module                      ##
#########################################################

# Validate global variables.
- name: Validate variables for Podman containers module...
  ansible.builtin.assert:
    that: varitem is defined
    fail_msg: Required variable '{{ varitem }}' has not been provided.
    quiet: true
  loop_control:
    loop_var: varitem
  loop:
    - container_repository_url
    - container_name

#########################################################
## Import container image                              ##
#########################################################
# Pull container image, if failed try to use local file
# local file can be http, https, ftp or local file

# CONTAINER IMAGE REGISTRY
# Get container image direct from registry
- name: Get container image from registry {{ container_repository_url }}:{{ container_repository_tag | default('latest') }}...
  when: container_repository_url != "" and not container_repository_url.endswith(".tar")
  block:
    # Show information
    - name: Show information
      ansible.builtin.debug:
        msg: Get container image from registry ({{ container_repository_url }}). this may take a while...

    # Pull image from repository to local image repository. If failed, lookup local image file.
    # become is true to pull into system wide (root) storage
    - name: Pull container image from repository {{ container_repository_url }}:{{ container_repository_tag | default('latest') }}...
      become: true
      become_user: "{{ podman_vars.service_user }}"
      ansible.builtin.command:
        cmd: podman pull {{ container_repository_url }}:{{ container_repository_tag | default('latest') }}
      register: pull_result
      ignore_errors: true

    # delete local temp file
    - name: Delete local file /tmp/{{ container_name }}.tar...
      become: true
      become_user: "{{ podman_vars.service_user }}"
      ansible.builtin.file:
        path: /tmp/{{ container_name }}.tar
        state: absent

    # Download container to /tmp/{{ container_name }}.tar when pull is succesfull
    - name: Save container image to /tmp/{{ container_name }}.tar...
      become: true
      become_user: "{{ podman_vars.service_user }}"
      ansible.builtin.command:
        cmd: podman save -o /tmp/{{ container_name }}.tar {{ container_repository_url }}:{{ container_repository_tag | default('latest') }}
      when: pull_result.rc == 0
      register: save_result

# LOCAL CONTAINER IMAGE FILE
# If local file, load image from local file
- name: Install local image file {{ container_repository_url }}...
  when: container_repository_url != "" and container_repository_url.endswith(".tar")
  block:
    # Show information message
    - name: Show information message
      ansible.builtin.debug:
        msg: Load container image from local file {{ container_repository_url }}. This may take a while...

    # Delete local temp file
    - name: Delete local file /tmp/{{ container_name }}...
      ansible.builtin.file:
        path: /tmp/{{ container_name }}.tar
        state: absent

    # repository_url is a local container file, check if file exists on ansible host
    - name: Check if repository_url is a local container file...
      ansible.builtin.stat:
        path: "{{ container_repository_url }}"
      register: container_repository_url_result
      delegate_to: localhost

    # Copy image file to destination if local file
    - name: Copy container image file to destination...
      ansible.builtin.copy:
        src: "{{ container_repository_url }}"
        dest: /tmp/{{ container_name }}.tar
      when:
        - container_repository_url_result.stat.exists == true

    # Download local file if http or https
    - name: Download file from {{ container_repository_url }}...
      ansible.builtin.get_url:
        url: "{{ container_repository_url }}"
        dest: /tmp/{{ container_name }}.tar
      when: ("http" in container_repository_url) or ("ftp" in container_repository_url) # https is included

# CHECK IF CONTAINER IMAGE FILE EXISTS
# Image file is saved to /tmp/{{ container_name }}.tar, check if exists
- name: Check if /tmp/{{ container_name }}.tar exists...
  ansible.builtin.stat:
    path: /tmp/{{ container_name }}.tar
  register: container_tar_result

# Fail if image file not found
- name: Fail if container image file not found...
  ansible.builtin.fail:
    msg: Repository URL {{ container_repository_url }} not found. Container image file location not found. Cannot continue...
  when: container_tar_result.stat.exists == false

#########################################################
## Checksum container image                            ##
#########################################################

# If checksum is defined, check item
# If container_repository_checksum is not defined, this block will be skipped.
- name: Parse checksum image
  when: not (container_repository_checksum | string is search('__omit_place_holder__'))
  block:
    # If checksum contains :, split it in checksum and algorithm
    - name: Split checksum and algorithm
      ansible.builtin.set_fact:
        repository_checksum: "{{ container_repository_checksum.split(':')[1] }}"
        repository_checksum_algorithm: "{{ container_repository_checksum.split(':')[0] }}"
      when: "':' in container_repository_checksum"

    # Get checksum of container file.tar
    - name: Get checksum of local container file
      ansible.builtin.stat:
        path: /tmp/{{ container_name }}.tar
        checksum_algorithm: "{{ container_repository_checksum_algorithm }}"
        get_checksum: true
      register: checksum_result

    # Fail when checksum is not the same
    - name: Fail when checksum is not correct
      ansible.builtin.fail:
        msg: Checksum of /tmp/{{ container_name }}.tar ({{ checksum_result.stat.checksum }}) is not the same as the provided checksum ({{ repository_checksum
          }}). Cannot continue...
      when: checksum_result.stat.checksum != container_repository_checksum

#########################################################
## Load container image                                ##
#########################################################

# Load image from file if pull failed
- name: Import container image {{ container_name }} to podman...
  become: true
  become_user: "{{ podman_vars.service_user }}"
  ansible.builtin.command: podman load -i /tmp/{{ container_name }}.tar
  register: import_result

# Set variable
- name: Register variable (image_name)
  ansible.builtin.set_fact:
    image_name: "{{ import_result.stdout | regex_search('Loaded image:\\s*(.*)', '\\1') | first }}"
    container_repository_tag: "{{ import_result.stdout | regex_search('Loaded image:\\s*(.*)', '\\1') | last }}"

# Get image info from podman
- name: Gather info on container image (file)...
  become: true
  become_user: "{{ podman_vars.service_user }}"
  ansible.builtin.command:
    cmd: podman image inspect {{ image_name }}
  register: images_info

# Find image id, do not use json_query as it is not installed on all systems
- name: Find image id...
  ansible.builtin.set_fact:
    image_id: "{{ (images_info.stdout | from_json)[0]['Id'] }}"

# Set default quadlet options for static container images
- name: Register variable (container_quadlet_options)
  ansible.builtin.set_fact:
    container_quadlet_options:
      - Environment={{ container_env | default(omit) }}
      - |
        [Install]
        WantedBy=default.target
  when: container_quadlet_options is not defined or container_quadlet_options == ""

# Add podman_data_folder before each item in container_volumes
- name: Gather volume folders...
  ansible.builtin.set_fact:
    _container_volumes: "{% for item in container_volumes %}{{ podman_vars.data_folder }}/{{ item }}{% if not loop.last %},{% endif %}{% endfor %}"

##################################
# Create container               #
##################################

# Set variable if not defined
- name: Register variable (container_privileged)...
  ansible.builtin.set_fact:
    container_privileged: false
  when: container_privileged is not defined or container_privileged is none or container_privileged == ""

# Set variable if not defined
- name: Register variable (container_security_opt)
  ansible.builtin.set_fact:
    container_security_opt: unset
  when: container_security_opt is not defined or container_security_opt is none or container_security_opt == ""

# Create podman container without security options
- name: Create container {{ container_name }} with id {{ image_id }}...
  become: true
  become_user: "{{ podman_vars.service_user }}"
  containers.podman.podman_container:
    name: "{{ container_name }}"
    pod: "{{ container_pod | default(omit) }}"
    image: "{{ image_id }}"
    state: quadlet
    arch: "{{ container_arch | default(omit) }}"
    ports: "{{ container_ports | default(omit) }}"
    volumes: "{{ _container_volumes | default(omit) }}"
    command: "{{ container_command | default(omit) }}"
    privileged: "{{ container_privileged | default(false) | bool }}"
    cap_add: "{{ container_cap_add | default(omit) }}"
    cap_drop: "{{ container_cap_drop | default(omit) }}"
    user: "{{ container_user | default(omit) }}"
    healthcheck: "{{ container_healthcheck | default(omit) }}"
    healthcheck_failure_action: "{{ container_healthcheck_fail | default('none') }}"
    healthcheck_retries: "{{ container_healthcheck_retries | default(omit) }}"
    healthcheck_interval: "{{ container_healthcheck_interval | default(omit) }}"
    healthcheck_start_period: "{{ container_healthcheck_start | default(omit) }}"
    healthcheck_timeout: "{{ container_healthcheck_timeout | default(omit) }}"
    quadlet_filename: container_{{ container_name }}
    quadlet_file_mode: "0640"
    quadlet_options: "{{ container_quadlet_options }}"
  when: container_security_opt is not defined or container_security_opt is none or container_security_opt == "unset"
  register: container_create_result

# Create podman container with security options
- name: Create container (security_opt) with id {{ image_id }} - ({{ container_name }}) ...
  become: true
  become_user: "{{ podman_vars.service_user }}"
  containers.podman.podman_container:
    name: "{{ container_name }}"
    pod: "{{ container_pod | default(omit) }}"
    image: "{{ image_id }}"
    state: quadlet
    arch: "{{ container_arch | default(omit) }}"
    ports: "{{ container_ports | default(omit) }}"
    volumes: "{{ _container_volumes | default(omit) }}"
    command: "{{ container_command | default(omit) }}"
    privileged: "{{ container_privileged | default(false) | bool }}"
    cap_add: "{{ container_cap_add | default(omit) }}"
    security_opt: "{{ container_security_opt | default(omit) }}"
    user: "{{ container_user | default(omit) }}"
    healthcheck: "{{ container_healthcheck | default(omit) }}"
    healthcheck_failure_action: "{{ container_healthcheck_fail | default('none') }}"
    healthcheck_retries: "{{ container_healthcheck_retries | default(omit) }}"
    healthcheck_interval: "{{ container_healthcheck_interval | default(omit) }}"
    healthcheck_start_period: "{{ container_healthcheck_start | default(omit) }}"
    healthcheck_timeout: "{{ container_healthcheck_timeout | default(omit) }}"
    env: "{{ container_env | default(omit) }}"
    quadlet_filename: container_{{ container_name }}
    quadlet_file_mode: "0640"
    quadlet_options: "{{ container_quadlet_options }}"
  when: container_security_opt != "unset"
  register: container_create_result

- name: Retrieve userId to enable systemd user base...
  ansible.builtin.getent:
    database: passwd
    key: "{{ podman_vars.service_user }}"

# Container is not part of a pod
# Ensure container is started and enabled
- name: Ensure container {{ container_name }} is started and enabled...
  become: true
  become_user: "{{ podman_vars.service_user }}"
  ansible.builtin.systemd:
    name: container_{{ container_name }}
    scope: user
    enabled: true
    daemon_reload: true
    state: started
  environment:
    XDG_RUNTIME_DIR: /run/user/{{ getent_passwd[ podman_vars.service_user ].1 }}
  when:
    - container_pod is not defined

#########################################################
## Post-actions                                        ##
#########################################################

# Check if /tmp/{{ container_name }}.tar exists, then delete it
- name: Gather file information...
  ansible.builtin.stat:
    path: /tmp/{{ container_name }}.tar
  register: tmp_file

- name: Cleanup file /tmp/{{ container_name }}.tar...
  ansible.builtin.file:
    path: /tmp/{{ container_name }}.tar
    state: absent
  when: tmp_file.stat.exists

# Unset variables
- name: Unset variables
  ansible.builtin.set_fact:
    container_repository_url:
    container_name:
    container_ports:
    container_volumes:
    _container_volumes:
    container_env:
    container_command:
    container_user:
    container_security_opt:
    container_privileged:
    container_cap_add:
    container_repository_tag:
    container_repository_checksum:
    image_id:
    pull_result:
    import_result:
    images_info:
    container_tar_result:
    checksum_result:
    container_repository_url_result:
